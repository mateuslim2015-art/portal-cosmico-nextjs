
import cron from 'node-cron';
import { PrismaClient } from '@prisma/client';
import webpush from 'web-push';
import { getNotificationMessage } from './notification-messages';

const prisma = new PrismaClient();

// Configurar VAPID keys
const vapidPublicKey = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY || '';
const vapidPrivateKey = process.env.VAPID_PRIVATE_KEY || '';
const vapidEmail = process.env.VAPID_EMAIL || 'mailto:contato@portalcosmico.com';

if (vapidPublicKey && vapidPrivateKey) {
  webpush.setVapidDetails(vapidEmail, vapidPublicKey, vapidPrivateKey);
}

interface NotificationPayload {
  title: string;
  body: string;
  icon: string;
  badge: string;
  data: {
    url: string;
    timestamp: number;
  };
}

// FunÃ§Ã£o para enviar notificaÃ§Ã£o
async function sendNotification(
  subscription: any,
  payload: NotificationPayload,
  userId: string,
  type: string
) {
  try {
    await webpush.sendNotification(
      subscription,
      JSON.stringify(payload)
    );

    // Registrar envio no analytics
    await prisma.notificationAnalytics.create({
      data: {
        userId,
        type,
        title: payload.title,
        sentAt: new Date(),
        delivered: true,
      },
    });

    return { success: true };
  } catch (error: any) {
    console.error('Erro ao enviar notificaÃ§Ã£o:', error);

    // Se a subscriÃ§Ã£o expirou (410), removÃª-la
    if (error.statusCode === 410) {
      await prisma.notificationSubscription.delete({
        where: { userId },
      });
    }

    return { success: false, error };
  }
}

// FunÃ§Ã£o para obter usuÃ¡rios elegÃ­veis para notificaÃ§Ã£o
async function getEligibleUsers() {
  const now = new Date();
  const users = await prisma.notificationSubscription.findMany({
    where: {
      enabled: true,
      user: {
        subscriptionStatus: 'active',
      },
    },
    include: {
      user: true,
      preferences: true,
    },
  });

  // Filtrar usuÃ¡rios baseado em preferÃªncias e Ãºltima notificaÃ§Ã£o
  const eligible = [];
  for (const sub of users) {
    const prefs = sub.preferences;
    if (!prefs) continue;

    // Verificar horÃ¡rio preferido
    const currentHour = now.getHours();
    const isInPreferredTime = 
      (prefs.morningEnabled && currentHour >= 6 && currentHour < 12) ||
      (prefs.afternoonEnabled && currentHour >= 12 && currentHour < 18) ||
      (prefs.eveningEnabled && currentHour >= 18 && currentHour < 23);

    if (!isInPreferredTime) continue;

    // Verificar frequÃªncia (nÃ£o enviar mais de 3 por dia)
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const sentToday = await prisma.notificationAnalytics.count({
      where: {
        userId: sub.userId,
        sentAt: {
          gte: today,
        },
      },
    });

    if (sentToday >= 3) continue;

    // Verificar cooldown (mÃ­nimo 3 horas entre notificaÃ§Ãµes)
    const lastNotification = await prisma.notificationAnalytics.findFirst({
      where: { userId: sub.userId },
      orderBy: { sentAt: 'desc' },
    });

    if (lastNotification) {
      const hoursSinceLastNotification = 
        (now.getTime() - lastNotification.sentAt.getTime()) / (1000 * 60 * 60);
      
      if (hoursSinceLastNotification < 3) continue;
    }

    eligible.push(sub);
  }

  return eligible;
}

// FunÃ§Ã£o para enviar notificaÃ§Ãµes em massa
export async function sendScheduledNotifications() {
  console.log('ðŸ”” Iniciando envio de notificaÃ§Ãµes agendadas...');
  
  const eligibleUsers = await getEligibleUsers();
  console.log(`ðŸ“Š ${eligibleUsers.length} usuÃ¡rios elegÃ­veis`);

  let successCount = 0;
  let failCount = 0;

  for (const sub of eligibleUsers) {
    try {
      // Selecionar tipo de notificaÃ§Ã£o baseado em preferÃªncias e comportamento
      const notificationType = await selectNotificationType(sub.userId, sub.preferences);
      
      const message = getNotificationMessage(notificationType);
      
      const payload: NotificationPayload = {
        title: message.title,
        body: message.body,
        icon: '/logo.png',
        badge: '/favicon.svg',
        data: {
          url: message.url,
          timestamp: Date.now(),
        },
      };

      const result = await sendNotification(
        JSON.parse(sub.subscription),
        payload,
        sub.userId,
        notificationType
      );

      if (result.success) {
        successCount++;
      } else {
        failCount++;
      }

      // Delay entre envios para evitar rate limiting
      await new Promise(resolve => setTimeout(resolve, 100));
    } catch (error) {
      console.error(`Erro ao processar usuÃ¡rio ${sub.userId}:`, error);
      failCount++;
    }
  }

  console.log(`âœ… Envios concluÃ­dos: ${successCount} sucesso, ${failCount} falhas`);
  
  return {
    total: eligibleUsers.length,
    success: successCount,
    failed: failCount,
  };
}

// FunÃ§Ã£o para selecionar tipo de notificaÃ§Ã£o baseado em comportamento
async function selectNotificationType(
  userId: string,
  preferences: any
): Promise<string> {
  // Buscar Ãºltimas leituras do usuÃ¡rio
  const recentReadings = await prisma.reading.findMany({
    where: { userId },
    orderBy: { createdAt: 'desc' },
    take: 5,
  });

  const lastReading = recentReadings[0];
  const daysSinceLastReading = lastReading
    ? (Date.now() - lastReading.createdAt.getTime()) / (1000 * 60 * 60 * 24)
    : 999;

  // LÃ³gica de triggers inteligentes
  if (daysSinceLastReading > 3) {
    // UsuÃ¡rio inativo - engajamento
    return preferences?.dailyCardEnabled ? 'daily_card' : 'engagement';
  } else if (daysSinceLastReading < 1 && recentReadings.length > 2) {
    // UsuÃ¡rio muito ativo - conteÃºdo educacional
    return preferences?.studyRemindersEnabled ? 'study_reminder' : 'card_meaning';
  } else {
    // UsuÃ¡rio moderado - mix de conteÃºdo
    const types = [];
    if (preferences?.dailyCardEnabled) types.push('daily_card');
    if (preferences?.studyRemindersEnabled) types.push('study_reminder');
    if (preferences?.readingRemindersEnabled) types.push('reading_reminder');
    types.push('tip', 'card_meaning');
    
    return types[Math.floor(Math.random() * types.length)];
  }
}

// FunÃ§Ã£o para enviar notificaÃ§Ã£o de comportamento especÃ­fico
export async function sendBehaviorTriggeredNotification(
  userId: string,
  triggerType: 'first_reading' | 'streak_achievement' | 'upgrade_prompt' | 'abandoned_reading'
) {
  try {
    const subscription = await prisma.notificationSubscription.findUnique({
      where: { userId },
      include: { preferences: true },
    });

    if (!subscription || !subscription.enabled) {
      return { success: false, reason: 'subscription_disabled' };
    }

    let message;
    switch (triggerType) {
      case 'first_reading':
        message = {
          title: 'ðŸŽ‰ ParabÃ©ns pela sua primeira leitura!',
          body: 'Continue sua jornada espiritual. Explore a biblioteca de cartas e aprofunde seus conhecimentos.',
          url: '/cards',
        };
        break;
      case 'streak_achievement':
        message = {
          title: 'ðŸ”¥ SequÃªncia de 7 dias!',
          body: 'IncrÃ­vel! VocÃª estÃ¡ construindo um hÃ¡bito poderoso. Continue sua prÃ¡tica diÃ¡ria.',
          url: '/dashboard',
        };
        break;
      case 'upgrade_prompt':
        message = {
          title: 'âœ¨ Desbloqueie Mais OrÃ¡culos',
          body: 'Seu teste estÃ¡ terminando. Assine agora e acesse Baralho Cigano, Runas e I-Ching!',
          url: '/dashboard',
        };
        break;
      case 'abandoned_reading':
        message = {
          title: 'ðŸ”® Sua leitura estÃ¡ esperando',
          body: 'VocÃª tem uma leitura incompleta. Volte e descubra o que as cartas querem revelar.',
          url: '/reading',
        };
        break;
    }

    const payload: NotificationPayload = {
      title: message.title,
      body: message.body,
      icon: '/logo.png',
      badge: '/favicon.svg',
      data: {
        url: message.url,
        timestamp: Date.now(),
      },
    };

    return await sendNotification(
      JSON.parse(subscription.subscription),
      payload,
      userId,
      triggerType
    );
  } catch (error) {
    console.error('Erro ao enviar notificaÃ§Ã£o de comportamento:', error);
    return { success: false, error };
  }
}

// Agendar envios automÃ¡ticos
let jobsInitialized = false;

export function initializeNotificationScheduler() {
  if (jobsInitialized) {
    console.log('âš ï¸ Scheduler jÃ¡ inicializado');
    return;
  }

  console.log('ðŸš€ Inicializando scheduler de notificaÃ§Ãµes...');

  // Envio matinal: 8h (horÃ¡rio do servidor)
  cron.schedule('0 8 * * *', async () => {
    console.log('â˜€ï¸ Executando envio matinal...');
    await sendScheduledNotifications();
  });

  // Envio tarde: 14h (horÃ¡rio do servidor)
  cron.schedule('0 14 * * *', async () => {
    console.log('ðŸŒ¤ï¸ Executando envio da tarde...');
    await sendScheduledNotifications();
  });

  // Envio noturno: 20h (horÃ¡rio do servidor)
  cron.schedule('0 20 * * *', async () => {
    console.log('ðŸŒ™ Executando envio noturno...');
    await sendScheduledNotifications();
  });

  jobsInitialized = true;
  console.log('âœ… Scheduler inicializado com sucesso!');
  console.log('ðŸ“… HorÃ¡rios agendados: 8h, 14h, 20h');
}
